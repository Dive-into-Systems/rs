<!DOCTYPE html>
<meta charset="utf-8">
<body>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/@hpcc-js/wasm@0.3.11/dist/index.min.js"></script>
<script src="https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js"></script>

<div id="timeline_graph" style="text-align: center;"></div>

<script>

    // function getEventsAttr() {
    //     return;
    // }
    // function connectNodes(values) {

    //     let edges = [];
    //     for (let i = 0; i < values.length; i++) {
    //         const [IDtime, print] = values[i].split(':');
    //         const [ID, timestep] = IDtime.split('.');
    //         if (print !== "[]") {
    //             if (!edges[ID]) {
    //                 edges[ID] = [];
    //             }
    //             edges[ID].push(print);
    //         }
    //     }
    //     return edges;
    // }

    // function getSubgraph(edges, i) {
    //     let subgraphString = (
    //         `subgraph cluster_${i} {` +
    //         `style=filled;` +
    //         `color=lightgrey;` +
    //         `node [style=filled,color=white];`
    //     );

    //     for (let e of edges) {
    //         subgraphString += `${e} -> a;`;
    //     }

    //     subgraphString = subgraphString.slice(0, -4); // Remove the last ' -> ' 
    //     subgraphString += '};';

    //     return subgraphString;
    // }

    // function drawTimeline(links, values) {

    //     const edges = connectNodes(values);

    //     let digraphString = (
    //         'digraph G {' +
    //         'bgcolor=transparent;' +
    //         'node [shape=box, color=black, style=filled, fillcolor=white];' +
    //         'edge [color=black, penwidth=2.0];' +
    //         'rankdir=LR;' +
    //         'splines=ortho;'
    //     );

    //     for (let i = 0; i < edges.length; i++) {
    //         digraphString += getSubgraph(edges, i);
    //     }

    //     digraphString += 'end [shape=Msquare];';
    //     digraphString += '}';

    //     console.log(digraphString);

    //     d3.select("#timeline_graph").graphviz()
    //         .renderDot(digraphString);
    // }

    // class ForkNode {
    //     constructor(id = 0, timestep = 0, value = "_", left = null, right = null) {
    //         this.id = id;
    //         this.timestep = timestep;
    //         this.value = value;
    //         this.left = left;
    //         this.right = right;
    //     }
    // }
    // const INDENT_SPC = 4;
    // const DASH = "â”€";
    // const BAR = "|";
    // const SPC = " ";
    // const NEWLINE = "\n";
    // let nodeCounter = 1;

    // function transpileToC(code, indent = 0, activeProcesses = ["0"]) {
    //     let result = [];
    //     let ptr = 0;
    //     let nextF;
    //     let leftCode, rightCode;

    //     function addLine(line) {
    //         result.push(`${SPC.repeat(indent)}${line}`);
    //     }

    //     while (ptr < code.length) {
    //         nextF = code.indexOf('f(', ptr);
    //         if (nextF === -1 || nextF > ptr) {
    //             // print plain text until 'f(' or end of string
    //             let end = nextF === -1 ? code.length : nextF;
    //             let text = code.substring(ptr, end);
    //             for (let i = 0; i < text.length; i++) {
    //                 addLine(`printf("${text[i]}");`);
    //             }
    //             ptr = end;
    //         }

    //         if (nextF !== -1 && ptr === nextF) {
    //             [leftCode, rightCode, ptr] = parseForkArgs(code, ptr);
    //             if (!leftCode && !rightCode) addLine("fork();");
    //             if (leftCode) {
    //                 addLine("if (fork()) {");
    //                 result = result.concat(transpileToC(leftCode, indent + INDENT_SPC));
    //                 addLine(rightCode ? "} else {" : "}");
    //             }
    //             if (rightCode) {
    //                 if (!leftCode) addLine("if (fork() == 0) {");
    //                 result = result.concat(transpileToC(rightCode, indent + INDENT_SPC));
    //                 addLine("}");
    //             }
    //         }
    //     }
    //     return result;
    // }

    // function parseForkArgs(code, forkIndex) {
    //     let balance = 1;
    //     let topLevelComma = null; // position of first top-level comma
    //     let [start, end] = [forkIndex + 2, forkIndex + 2]; // after 'f('
    //     while (end < code.length) {
    //         if (code[end] === '(') balance++;
    //         if (code[end] === ')') balance--;
    //         if (balance === 0) break; // found closing bracket
    //         if (balance === 1 && code[end] === ',') topLevelComma ??= end; // only assigns top comma once
    //         end++;
    //     }

    //     if (!topLevelComma) return [code.substring(start, end), '', end + 1];
    //     return [
    //         code.substring(start, topLevelComma),
    //         code.substring(topLevelComma + 1, end),
    //         end + 1 // next index
    //     ];
    // }

    // function buildTree(code, id = 0, time = 0, childCt = 0) {
    //     code = code.trim();
    //     if (code.length === 0) {
    //         return new ForkNode(
    //             id,
    //             time,
    //             "",
    //             null, null
    //         );
    //     }

    //     const exitIndex = code.indexOf("x");
    //     let forkIndex = code.indexOf('f(');
    //     let hasFork = true;
    //     if (forkIndex === -1) {
    //         hasFork = false;
    //         forkIndex = code.length; // no fork, plain print node
    //     }

    //     if (exitIndex!==-1 && exitIndex < forkIndex) {
    //         forkIndex = exitIndex+1;
    //         code = code.substring(0, exitIndex+1); // capture exit char
    //     }
    //     // return new ForkNode(id, time, code);
    //     let [leftCode, rightCode, end] = parseForkArgs(code, forkIndex);
    //     leftCode += code.substring(end).trim(); // remaining code
    //     rightCode += code.substring(end).trim(); // remaining code
    //     // childCt += rightCode?1:0;
    //     childCt += (hasFork)?1:0;
    //     console.log(code, hasFork);
    //     const leftNode = hasFork?buildTree(leftCode, id, time+1, childCt):null;
    //     const rightNode = hasFork?buildTree(rightCode, (id*10)+childCt, 0):null;
    //     return new ForkNode(
    //         id,
    //         time,
    //         code.substring(0, forkIndex).trim() ?? "",
    //         leftNode,
    //         rightNode
    //     );
    // }

    // const formatNode = (node) => `${node.id}${node.timestep}${node.value}`;

    // function getTreeArr(root, parentVal = "", result = new Set(), valuesMap = new Map()) {
    //     if (!root) return { treeSet: result, valuesMap };

    //     // Add the parent-child entry to the set if IDs are different
    //     // const entry = `${root.id}${parentVal ? ("," + parentVal) : ""}`;
    //     const entry = `${root.id},${parentVal}`;  // Always include parent ID, even if it's an empty string
    //     if (root.id.toString() !== parentVal.toString()) {
    //         result.add(entry);
    //     }

    //     // Aggregate values by ID in a Map
    //     if (valuesMap.has(root.id)) {
    //         valuesMap.get(root.id).push(root.value);
    //     } else {
    //         valuesMap.set(root.id, [root.value]);
    //     }

    //     // Recursive calls to traverse left and right children
    //     getTreeArr(root.left, `${root.id}`, result, valuesMap);
    //     getTreeArr(root.right, `${root.id}`, result, valuesMap);

    //     return { treeSet: result, valuesMap };
    // }

    // function getTreeCSV(root) {
    //     const { treeSet, valuesMap } = getTreeArr(root);
    //     const csvString = "child,parent\n" + Array.from(treeSet).join("\n");

    //     const valuesArray = Array.from(valuesMap, ([id, values]) => `${id}:[${values.map(value => value)}]`);
    //     return { csv: csvString, valuesList: valuesArray };
    // }

    // // function printTreeVert(node, isRoot = true, values = []) {
    // // const nullChar = "[]";
    // //     // if (!node) return [nullChar]; // show forked processes that does nothing
    // //     if (!node) return [];
    
    // //     const leftSubtree = printTreeVert(node.left, false);
    // //     const rightSubtree = printTreeVert(node.right, false);

    // //     const hasLeft = leftSubtree.length > 0;
    // //     const hasRight = rightSubtree.length > 0;
    
    // //     const selfValue = (`${node.id}.${node.timestep}`)+ ":"+(node.value?node.value:nullChar);
    // //     values.push(selfValue);
        
    // //     // spacing for subtrees
    // //     const leftWidth = leftSubtree.length > 0 ? Math.max(...leftSubtree.map(item => item.length)) : 0;
    // // ;
    // //     const indentRight = (hasLeft ? "|" : " ") + "_".repeat(Math.max(selfValue.length, leftWidth));
    
    // //     const result = [];
    // //     result.push(`${selfValue}${hasRight ? DASH.repeat(Math.max(selfValue.length, leftWidth)-selfValue.length+1) + rightSubtree[0] : ""}`);
    // //     rightSubtree.slice(1).forEach(line => result.push(`${indentRight}${line}`));
    // //     // if (hasLeft) result.push(BAR);
    // //     leftSubtree.forEach(line => result.push(line+SPC.repeat(leftWidth-line.length)));

    // //     return isRoot ? result.join("\n") : result;
    // // }

    // function printTreeVert(node, isRoot = true, values = []) {
    //     const nullChar = "[]";
    //     if (!node) return { treeLines: [], values };

    //     const leftResult = printTreeVert(node.left, false, values);
    //     const rightResult = printTreeVert(node.right, false, values);

    //     const leftSubtree = leftResult.treeLines;
    //     const rightSubtree = rightResult.treeLines;

    //     const hasLeft = leftSubtree.length > 0;
    //     const hasRight = rightSubtree.length > 0;

    //     const selfValue = `${node.id}.${node.timestep}:${node.value ? node.value : nullChar}`;
    //     values.push(selfValue);  // Add selfValue to the array

    //     // spacing for subtrees
    //     const leftWidth = leftSubtree.length > 0 ? Math.max(...leftSubtree.map(item => item.length)) : 0;
    //     const indentRight = (hasLeft ? "|" : " ") + "_".repeat(Math.max(selfValue.length, leftWidth));

    //     const result = [];
    //     result.push(`${selfValue}${hasRight ? DASH.repeat(Math.max(selfValue.length, leftWidth) - selfValue.length + 1) + rightSubtree[0] : ""}`);
    //     rightSubtree.slice(1).forEach(line => result.push(`${indentRight}${line}`));
    //     leftSubtree.forEach(line => result.push(line + " ".repeat(leftWidth - line.length)));

    //     return isRoot ? { treeLines: result.join("\n"), values } : { treeLines: result, values };
    // }
    
    // console.log("-".repeat(10));

    // const source = "f(,f(a,)b)cf(d,)";
    // console.log(transpileToC(source).join(NEWLINE));

    // let tree = buildTree(source);
    // const { treeLines, values } = printTreeVert(tree);
    // console.log("Tree visualization:");
    // console.log(treeLines);
    // console.log("All node values:");
    // console.log(values);
    // const { csv: linksCsv, valuesList: labels } = getTreeCSV(tree);

    // // console.log("Links CSV: " + linksCsv);
    // // console.log("Labels: " + labels);

    // const links = d3.csvParse(linksCsv);
    // // console.log("Parsed links: " + links);

    // // drawHierarchy(links, labels);
    // drawTimeline(links, values);


    function getItemCoordinate(item) {
        left_x = item.left;
        top_y = item.parent.top + item.parent.height - item.top - item.height;
        return {
            left: left_x,
            top: top_y,
            right: left_x + item.width,
            bottom: top_y + item.height,
            mid_x: left_x + item.width / 2,
            mid_y: top_y + item.height / 2,
            width: item.width,
            height: item.height
        };
    }

    function getItemRelations(links) {
        return;
    }

    function initGraph(svg) {
        let width = +svg.attr("width");
        let height = +svg.attr("height");

        var data = [10, 15, 20, 25, 40];

        // Define the scale and axis
        var xscale = d3.scaleLinear().domain([0, d3.max(data)]).range([0, width - 100]);
        var yscale = d3.scaleLinear().domain([0, d3.max(data)]).range([height / 1.5, 0]);

        var x_axis = d3.axisBottom().scale(xscale);
        var y_axis = d3.axisLeft().scale(yscale);

        let gYAxis = svg.append("g").attr("transform", "translate(50, 10)").call(y_axis);
        var xAxisTranslate = height / 1.5 + 10;
        let gXAxis = svg.append("g").attr("transform", `translate(50, ${xAxisTranslate})`).call(x_axis);

        svg.append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 0 10 10")
            .attr("refX", "5")
            .attr("refY", "5")
            .attr("markerWidth", "6")
            .attr("markerHeight", "6")
            .attr("orient", "auto-start-reverse")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("fill", "red");

        // Get the bounding box of the x-axis group
        let bbox = gYAxis.node().getBBox();
        let lineY = bbox.y + bbox.height + 10;
        svg.append("line")
            .attr("x1", 50)
            .attr("y1", lineY + 30)
            .attr("x2", width - 50)
            .attr("y2", lineY + 30)
            .attr("stroke", "red")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");

        // Add "Time" label below the line
        svg.append("text")
            .attr("x", (width - 100) / 2 + 50)
            .attr("y", lineY + 50)
            .attr("fill", "red")
            .style("text-anchor", "middle")
            .style("font-family", "Arial")
            .style("font-size", "14px")
            .text("Time");
    }

    function drawTimeline() {   
        const links = '0,\n2,0\n1,0\n12,1\n11,1\n111,11';
        const labels = '0:[,c,d],2:[],1:[,abc,d],12:[],11:[bc,d],111:[]';

        var svg = d3.select("svg");
        initGraph(svg);
    }

</script>
</body>