<!DOCTYPE html>

<body>
    <svg width="1000" height="600"></svg>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
    const INDENT_SPC = 4;
    const DASH = "-";
    const BAR = "|";
    const SPC = " ";
    const NEWLINE = "\n";
    let nodeCounter = 1;

    function getItemsCoordinates(ids, times, valuesMap) {
        var idToX = {};
        var timeToY = {};
        const spacingX = 100;
        const spacingY = 50;

        ids.forEach((id, idx) => { idToX[id] = idx * spacingX; });
        times.forEach((t, idx) => { timeToY[t] = idx * spacingY; });

        let coordinates = valuesMap.map(item => ({
            id: item.id,
            time: item.time,
            content: item.content,
            x: idToX[item.id],
            y: timeToY[item.time]
        }));

        return coordinates;
    }

    function getItemsRelations(values) {
        let valuesMap = values.map(val => {
            const [idTime, content] = val.split(':');
            const [id, time] = idTime.split('.');
            return { id, time, content };
        });
        return valuesMap;
    }

    function drawTimeline(values) {
        // console.log("ID, time, prints:", getItemRelations(values));
        const valuesMap = getItemsRelations(values);
        let ids = new Set(valuesMap.map(items => items.id));
        let times = new Set(valuesMap.map(items => items.time));
        ids = Array.from(ids);
        times = Array.from(times).sort();
        console.log("IDs:", ids, "Times:", times);
        const coords = getItemsCoordinates(ids, times, valuesMap);
        console.log(coords);
        var svg = d3.select("svg");
        coords.forEach(item => {
                svg.append("text")
                .attr("x", item.x + 50)  // Adjusting position to fit within the SVG
                .attr("y", item.y + 10)
                .text(`${item.id}.${item.time}: ${item.content}`)
                .attr("fill", "black");
            });
        return;
    }

    function initGraph(svg) {
        let width = +svg.attr("width");
        let height = +svg.attr("height");

        var data = [10, 15, 20, 25, 40];

        // Define the scale and axis
        var xscale = d3.scaleLinear().domain([0, d3.max(data)]).range([0, width - 100]);
        var yscale = d3.scaleLinear().domain([0, d3.max(data)]).range([height / 1.5, 0]);

        var x_axis = d3.axisBottom().scale(xscale);
        var y_axis = d3.axisLeft().scale(yscale);

        let gYAxis = svg.append("g").attr("transform", "translate(50, 10)").call(y_axis);
        var xAxisTranslate = height / 1.5 + 10;
        let gXAxis = svg.append("g").attr("transform", `translate(50, ${xAxisTranslate})`).call(x_axis);

        svg.append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 0 10 10")
            .attr("refX", "5")
            .attr("refY", "5")
            .attr("markerWidth", "6")
            .attr("markerHeight", "6")
            .attr("orient", "auto-start-reverse")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("fill", "red");

        // Get the bounding box of the x-axis group
        let bbox = gYAxis.node().getBBox();
        let lineY = bbox.y + bbox.height + 10;
        svg.append("line")
            .attr("x1", 50)
            .attr("y1", lineY + 30)
            .attr("x2", width - 50)
            .attr("y2", lineY + 30)
            .attr("stroke", "red")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");

        // Add "Time" label below the line
        svg.append("text")
            .attr("x", (width - 100) / 2 + 50)
            .attr("y", lineY + 50)
            .attr("fill", "red")
            .style("text-anchor", "middle")
            .style("font-family", "Arial")
            .style("font-size", "14px")
            .text("Time");
    }

    class ForkNode {
        constructor(id = 0, timestep = 0, value = "_", left = null, right = null) {
            this.id = id;
            this.timestep = timestep;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
    function parseForkArgs(code, forkIndex) {
        let balance = 1;
        let topLevelComma = null; // position of first top-level comma
        let [start, end] = [forkIndex + 2, forkIndex + 2]; // after 'f('
        while (end < code.length) {
            if (code[end] === '(') balance++;
            if (code[end] === ')') balance--;
            if (balance === 0) break; // found closing bracket
            if (balance === 1 && code[end] === ',') topLevelComma ??= end; // only assigns top comma once
            end++;
        }

        if (!topLevelComma) return [code.substring(start, end), '', end + 1];
        return [
            code.substring(start, topLevelComma),
            code.substring(topLevelComma + 1, end),
            end + 1 // next index
        ];
    }
    function getTreeArr(root, parentVal = "", result = new Set(), valuesMap = new Map()) {
        if (!root) return { treeSet: result, valuesMap };

        // Add the parent-child entry to the set if IDs are different
        // const entry = `${root.id}${parentVal ? ("," + parentVal) : ""}`;
        const entry = `${root.id},${parentVal}`;  // Always include parent ID, even if it's an empty string
        if (root.id.toString() !== parentVal.toString()) {
            result.add(entry);
        }

        // Aggregate values by ID in a Map
        if (valuesMap.has(root.id)) {
            valuesMap.get(root.id).push(root.value);
        } else {
            valuesMap.set(root.id, [root.value]);
        }

        // Recursive calls to traverse left and right children
        getTreeArr(root.left, `${root.id}`, result, valuesMap);
        getTreeArr(root.right, `${root.id}`, result, valuesMap);

        return { treeSet: result, valuesMap };
    }
    function buildTree(code, id = 0, time = 0, childCt = 0) {
        code = code.trim();
        if (code.length === 0) {
            return new ForkNode(
                id,
                time,
                "",
                null, null
            );
        }

        const exitIndex = code.indexOf("x");
        let forkIndex = code.indexOf('f(');
        let hasFork = true;
        if (forkIndex === -1) {
            hasFork = false;
            forkIndex = code.length; // no fork, plain print node
        }

        if (exitIndex!==-1 && exitIndex < forkIndex) {
            forkIndex = exitIndex+1;
            code = code.substring(0, exitIndex+1); // capture exit char
        }
        // return new ForkNode(id, time, code);
        let [leftCode, rightCode, end] = parseForkArgs(code, forkIndex);
        leftCode += code.substring(end).trim(); // remaining code
        rightCode += code.substring(end).trim(); // remaining code
        // childCt += rightCode?1:0;
        childCt += (hasFork)?1:0;
        console.log(code, hasFork);
        const leftNode = hasFork?buildTree(leftCode, id, time+1, childCt):null;
        const rightNode = hasFork?buildTree(rightCode, (id*10)+childCt, 0):null;
        return new ForkNode(
            id,
            time,
            code.substring(0, forkIndex).trim() ?? "",
            leftNode,
            rightNode
        );
    }
    function printTreeVert(node, isRoot = true, values = []) {
        const nullChar = "[]";
        if (!node) return { treeLines: [], values };

        const leftResult = printTreeVert(node.left, false, values);
        const rightResult = printTreeVert(node.right, false, values);

        const leftSubtree = leftResult.treeLines;
        const rightSubtree = rightResult.treeLines;

        const hasLeft = leftSubtree.length > 0;
        const hasRight = rightSubtree.length > 0;

        const selfValue = `${node.id}.${node.timestep}:${node.value ? node.value : nullChar}`;
        values.push(selfValue);  // Add selfValue to the array

        // spacing for subtrees
        const leftWidth = leftSubtree.length > 0 ? Math.max(...leftSubtree.map(item => item.length)) : 0;
        const indentRight = (hasLeft ? "|" : " ") + "_".repeat(Math.max(selfValue.length, leftWidth));

        const result = [];
        result.push(`${selfValue}${hasRight ? DASH.repeat(Math.max(selfValue.length, leftWidth) - selfValue.length + 1) + rightSubtree[0] : ""}`);
        rightSubtree.slice(1).forEach(line => result.push(`${indentRight}${line}`));
        leftSubtree.forEach(line => result.push(line + " ".repeat(leftWidth - line.length)));

        return isRoot ? { treeLines: result.join("\n"), values } : { treeLines: result, values };
    }

    const source = "f(,f(a,)b)cf(d,)";
    const tree = buildTree(source);
    const { treeLines, values } = printTreeVert(tree);
    console.log(values);

    drawTimeline(values);
    // initGraph(svg);

    </script>
</body>