// *********
// circuit.js
// *********
/*
 * - This file contains the JS for the logic circuit component.
 * - The goal for this component is to randomly generate a logic circuit in
 *   a visualized form and let the user fill in the truth table.
 * - Basic logic of this JS:
 *   - Generate text expression of the circuit such as (A NOR B) AND C:
 *     - generateCircuit() describes all the behaviors when the generateButton
 *       button is clicked. It includes generating the text expression, 
 *       displaying the truth table, and visualize the text into a circuit. 
 *     - parseExpression() is the function used to parse the text expression
 *       into a tree for generating JSON file later. Parent node of the tree
 *       is the last gate that is connecting the output, so this is a reverse
 *       tree.
 *     - generateJSON() takes both the tree node and the text expression as 
 *       parameters and generate a JSON object ready to be loaded into the
 *       circuit visualization tool that GoJS library created.
 *       Here is the GoJS library sample:
 *          https://gojs.net/latest/samples/logicCircuit.html
 *     - init() is the GoJS function that defines layout and behavior of 
 *       all logic gates we might need. Not really necessary to make any
 *       changes as the functionality is already desirable enough.
 *     - load() is where the JSON object generated by the generateJSON() is
 *       passed in.
 * 
 * THIS IS NOT A RUNESTONE COMPONENT YET...IN ORDER TO RUN IT:
 *   · https://codepen.io/Yana-Yuan/pen/XWLbKwJ?editors=1011 (this is an online
 *     JS/CSS/HTML compiler that allows you to see real-time changes)
 *   · Create a new CodePen file and copy paste JS/CSS/HTML files in the 
 *     circuit repo into corresponding sections in the CodePen.
 *   · The first method is to let you view current progress while the second
 *     allows editing and saving. Make it into a Runestone component might
 *     be a better method. 
*/

var json;
var red = 'orangered'; // 0 or false
var green = 'forestgreen'; // 1 or true
var myDiagram; // Declare myDiagram globally

document.getElementById('generateButton').addEventListener('click', generateCircuit);

function generateCircuit() {
    const inputs = ['A', 'B', 'C'];
    const gates = ['AND', 'OR', 'XOR', 'NAND', 'NOR'];
    const gates2 = ['AND', 'OR', 'XOR'];
    const notGate = 'NOT';
    let maxGates = 3;
    let exactGates = 0;
    let numGates = 0;

    function getRandomElement(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function generateSubExpression(depth = 0) {
        if (depth > 3 || numGates >= maxGates) {
            return getRandomElement(inputs);
        }

        const chance = Math.random();
        if (chance < 0.5 && depth != 0) {
            return getRandomElement(inputs);
        } else if (chance < 0.58) {
            numGates = numGates + 1;
            let input = generateSubExpression(depth + 1);
            if (input.length == 1 || input[2]=='T'){
              return `${notGate}(${input})`;
            } else{
              return `${notGate}${input}`;
            }
        } else {
            numGates = numGates + 1;
            const gate = getRandomElement(gates);
            let input1 = generateSubExpression(depth + 1);
            let input2 = generateSubExpression(depth + 1);
            while ((input1.replace(/NOT\(|\)|\(/g, '') === input2.replace(/NOT\(|\)|\(/g, '')) && (input1.replace(/NOT\(|\)|\(/g, '').length==1)) {
                input2 = generateSubExpression(depth + 1);
            }
            return `(${input1} ${gate} ${input2})`;
        }
    }

      let circuit = generateSubExpression();
      if (exactGates != 0){
          while (numGates != exactGates){
          numGates = 0;
          circuit = generateSubExpression();
          // console.log("number of gates", numGates);
          }
      }
      // console.log("number of gates final ", numGates);

    document.getElementById('circuitOutput').innerText = circuit;

    displayTruthTable(circuit);
  
    let ast = parseExpression(circuit);

    // visualizeAST(ast);
  
    json = generateJSON(ast, circuit);
    // console.log(json);
    // let jsonString = JSON.stringify(json, null, 2);
    // jsonString = jsonString.replace(/'/g, '"');
    // console.log(jsonString);
    // init();
    load();
}

function evaluateExpression(expr, values) {
    // Replace variables with values
    for (const [key, value] of Object.entries(values)) {
        const re = new RegExp(`\\b${key}\\b`, 'g');
        expr = expr.replace(re, value ? 1 : 0);
    }

    expr = expr.replace(/NAND/g, 'NAND_PLACEHOLDER')
               .replace(/NOR/g, 'NOR_PLACEHOLDER')
               .replace(/XOR/g, '^')
               .replace(/ AND /g, ' & ')
               .replace(/ OR /g, ' | ')
               .replace(/NOT(\d+)/g, '!($1)')
               .replace(/NOT\(([^()]+)\)/g, '!($1)')
               .replace(/NOT/g, '!');

    // console.log('After replacement:', expr);

    function removeExtraParentheses(exp) {
        return exp.replace(/\((\d+)\)/g, '$1');
    }

    function evaluateInnermost(exp) {
        let prevExp;
        let iterations = 0;
        while (/\(([^()]+)\)/.test(exp) && iterations < 100) {
            prevExp = exp;
            exp = exp.replace(/\(([^()]+)\)/g, (match, subExpr) => {
                try {
                    const evaluated = eval(subExpr);
                    // console.log(`Evaluated sub-expression: (${subExpr}) -> ${evaluated}`);
                    return evaluated ? 1 : 0;
                } catch {
                    return match;
                }
            });
            exp = removeExtraParentheses(exp);
            if (prevExp === exp) break;
            iterations++;
        }
        return exp;
    }

    function replacePlaceholders(exp) {
        let prevExpr;
        let iterations = 0;
        do {
            prevExpr = exp;
            exp = exp.replace(/(\d+) NAND_PLACEHOLDER (\d+)/g, '!($1 & $2)')
                     .replace(/(\d+) NOR_PLACEHOLDER (\d+)/g, '!($1 | $2)');
            exp = removeExtraParentheses(exp); 
            iterations++;
            if (iterations >= 100) break;
        } while (prevExpr !== exp);
        return exp;
    }

    function handleSimpleNOTs(exp) {
        exp = exp.replace(/!([01])/g, (match, p1) => {
            const result = !parseInt(p1, 10) ? 1 : 0;
            // console.log(`Evaluated simple NOT: !${p1} -> ${result}`);
            return result;
        });
        exp = removeExtraParentheses(exp); 
        return exp;
    }

    function handleComplexNOTs(exp) {
        exp = exp.replace(/!\(([^()]+)\)/g, (match, subExpr) => {
            const result = !eval(subExpr) ? 1 : 0;
            // console.log(`Evaluated complex NOT: !(${subExpr}) -> ${result}`);
            return result;
        });
        exp = removeExtraParentheses(exp);
        return exp;
    }

    let prevExpr;
    do {
        prevExpr = expr;
        expr = evaluateInnermost(expr);
        expr = handleSimpleNOTs(expr);
        expr = replacePlaceholders(expr);
        expr = handleComplexNOTs(expr);
        expr = removeExtraParentheses(expr);
    } while (prevExpr !== expr); 

    // console.log('Evaluating expression:', expr);
    try {
        const result = eval(expr);
        // console.log('Expression:', expr, 'Values:', values, 'Result:', result);
        return result;
    } catch (e) {
        // console.error('Error evaluating expression:', e);
        return false;
    }
}

function extractInputs(circuit) {
    const inputSet = new Set();
    const inputPattern = /\b[A-Z]\b/g;
    let match;
    while ((match = inputPattern.exec(circuit)) !== null) {
        inputSet.add(match[0]);
    }
    // console.log("extract inputs ", Array.from(inputSet).sort());
    return Array.from(inputSet).sort();
}

function displayTruthTable(circuit) {
    const inputs = extractInputs(circuit);
    const table = document.getElementById('truthTable');
    table.innerHTML = ''; // Clear previous table

    // Create table header
    let header = '<tr>';
    for (const input of inputs) {
        header += `<th>${input}</th>`;
    }
    header += '<th>Output</th></tr>';
    table.innerHTML = header;

    // Generate truth table rows
    const numRows = Math.pow(2, inputs.length);
    for (let i = 0; i < numRows; i++) {
        const values = {};
        for (let j = 0; j < inputs.length; j++) {
            values[inputs[j]] = Boolean(i & (1 << (inputs.length - 1 - j)));
        }

        const output = evaluateExpression(circuit, values);

        let row = '<tr>';
        for (const input of inputs) {
            row += `<td>${values[input] ? 1 : 0}</td>`;
        }
        row += `<td>${output ? 1 : 0}</td></tr>`;
        table.innerHTML += row;
    }
}

function parseExpression(expression) {
    const operators = ['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'];
    const inputs = ['A', 'B', 'C'];
    let tokens = expression.match(/\(|\)|\w+|AND|OR|XOR|NAND|NOR|NOT/g);

    function parse(tokens) {
        let stack = [];
        let output = [];
        let precedence = {
            'OR': 1,
            'XOR': 1,
            'AND': 1,
            'NOR': 1,
            'NAND': 1,
            'NOT': 2
        };

        function peek(arr) {
            return arr[arr.length - 1];
        }

        function isOperator(token) {
            return operators.includes(token);
        }
      
        function isInput(token){
            return inputs.includes(token);
        }

        tokens.forEach(token => {
            if (isInput(token)) {
                output.push({ type: 'INPUT', value: token });
            } else if (isOperator(token)) {
                while (stack.length && precedence[peek(stack)] >= precedence[token]) {
                    output.push(stack.pop());
                }
                stack.push(token);
            } else if (token === '(') {
                stack.push(token);
            } else if (token === ')') {
                while (stack.length && peek(stack) !== '(') {
                    output.push(stack.pop());
                }
                stack.pop();
            }
        });

        while (stack.length) {
            output.push(stack.pop());
        }
      
        let ast = [];
        output.forEach(token => {
            if (isOperator(token)) {
                let node = { type: 'OPERATOR', value: token, children: [] };
                if (token === 'NOT') {
                    node.children.push(ast.pop());
                } else {
                    node.children.push(ast.pop());
                    node.children.push(ast.pop());
                }
                ast.push(node);
            } else {
                ast.push(token);
            }
        });
        // console.log(ast[0]);
        return ast[0];
    }

    return parse(tokens);
}

function visualizeAST(node, indent = 0) {
    if (!node) return;

    let treeVisual = [];

    function buildVisual(node, depth) {
        let spacing = ' '.repeat(depth * 2);
        if (node.type === 'INPUT') {
            treeVisual.push(`${spacing}${node.value}`);
        } else {
            treeVisual.push(`${spacing}${node.value}`);
            node.children.forEach(child => buildVisual(child, depth + 1));
        }
    }

    buildVisual(node, indent);
    document.getElementById('astOutput').innerText = treeVisual.join('\n');
}

function generateJSON(node, circuit) {
    let nodeDataArray = [];
    let linkDataArray = [];
    let nodeId = -1;
    let inputNodes = extractInputs(circuit);
    inputNodes.sort();
    let inputKeyMapping = {};
  
    function getNextNodeId() {
        return nodeId--;
    }

    function generateInputNodes(inputNodes) {
      const inputOrder = { 'A': 2, 'B': 1, 'C': 0 };
      inputNodes.sort((a, b) => inputOrder[a] - inputOrder[b]);

      inputNodes.forEach((input, index) => {
          let inputId = getNextNodeId();
          inputKeyMapping[input] = inputId;
          let locationY;

          if (inputNodes.length === 1) {
              locationY = 0; // one input
          } else if (inputNodes.length === 2) {
              locationY = (index === 0) ? 80 : -80;
          } else if (inputNodes.length === 3) {
              if (index === 0) {
                  locationY = 80; // First input (A)
              } else if (index === 1) {
                  locationY = 0; // Second input (B)
              } else {
                  locationY = -80; // Third input (C)
              }
          }

          nodeDataArray.push({
              category: 'input',
              key: inputId,
              loc: `0 ${locationY}`
          });
      });
      // console.log(inputKeyMapping);
    }
    generateInputNodes(inputNodes);  
  
    function preprocessTree(node, depth = 0, layers = {}) {
        if (node.type === 'INPUT') {
            return;
        }
        layers[depth] = (layers[depth] || 0) + 1;
        node.children.forEach(child => preprocessTree(child, depth + 1, layers));
      
        return layers;
    }
  
    let layers = preprocessTree(node);
    let currId = -inputNodes.length-1;
    function setPosition(node, depth = 0, layers, positions = {}) {
        if (node.type === 'INPUT') return;

        let width = 400;
        let numLevels = Object.keys(layers).length;
        let interval = width / (numLevels + 1);
        let xPosition = width - interval * (depth + 1);
        let yPosition = 0;

        // Initialize positions count if not already done
        if (!positions[depth]) positions[depth] = 0;

        // Calculate Y position based on number of nodes at this depth
        let numGatesAtDepth = layers[depth];
        let midPoint = Math.floor(numGatesAtDepth / 2);
        yPosition = (positions[depth] - midPoint) * 100;

        // Increment position count for this depth
        positions[depth]++;

        // Add node to nodeDataArray
        nodeDataArray.push({
            category: node.value.toLowerCase(),
            key: currId--,
            loc: `${xPosition} ${yPosition}`
        });

        // Recurse for children
        node.children.forEach(child => setPosition(child, depth + 1, layers, positions));
    }

    setPosition(node, 0, layers);
    let outputId = currId;
    // console.log(outputId);
    nodeDataArray.push({
        category: "output",
        key: outputId,
        loc: "400 0"
    });
    linkDataArray.push({
        from: -inputNodes.length-1,
        to: outputId,
        fromPort: 'out',
        toPort: ''
    });
 
    function traverse(node, parentId = null, depth = 0) {
        let currentId;
        let category;
      
        if (node.type === 'INPUT'){
          return;
        }
        else {
            currentId = getNextNodeId();
            category = node.value.toLowerCase();
            // nodeDataArray.push({ category: category, key: currentId, loc: '' });
        }
      
        if (node.children) {
            if (node.children.length === 1) { //one child
              if (node.children[0].type === 'INPUT'){ //one child is input
                  linkDataArray.push({
                    from: inputKeyMapping[node.children[0].value],
                    to: currentId,
                    fromPort: '',
                    toPort: 'in1'
                  }); 
              } else{ //one child is gate
                linkDataArray.push({
                    from: currentId-1,
                    to: currentId,
                    fromPort: 'out',
                    toPort: 'in1'
                  });
                traverse(node.children[0], currentId, '');
              }
              }
            if (node.children.length > 1) { //two children
                  let toport = 'in1';
                  let firstInput = true;
                  node.children.forEach(child => {
                  if (child.type === 'INPUT'){
                    linkDataArray.push({
                      from: inputKeyMapping[child.value],
                      to: currentId,
                      fromPort: '',
                      toPort: firstInput ? 'in1' : 'in2'
                  });
                    firstInput = false;
                  } else{
                    linkDataArray.push({
                      from: currentId-1,
                      to: currentId,
                      fromPort: 'out',
                      toPort: firstInput ? 'in1' : 'in2'
                    });
                    traverse(child, currentId, '');
                    firstInput = false;
                  }
                });
            }
        }
    }

    traverse(node);

    return {
        class: "go.GraphLinksModel",
        linkFromPortIdProperty: "fromPort",
        linkToPortIdProperty: "toPort",
        nodeDataArray: nodeDataArray,
        linkDataArray: linkDataArray
    };
}

/*==============================================
=== Circuit Visualization using GoJS Library ===
===============================================*/
function init() {
    var $ = go.GraphObject.make; // for conciseness in defining templates

    myDiagram =
            $(go.Diagram, "myDiagramDiv",  // create a new Diagram in the HTML DIV element "myDiagramDiv"
            {
                initialContentAlignment: go.Spot.Center,
                allowDrop: true,  // Nodes from the Palette can be dropped into the Diagram
                "draggingTool.isGridSnapEnabled": true,  // dragged nodes will snap to a grid of 10x10 cells
                "undoManager.isEnabled": true
            });

    // install the PortShiftingTool as a "mouse move" tool
        myDiagram.toolManager.mouseMoveTools.insertAt(0, new PortShiftingTool());
  
    myDiagram.addDiagramListener('Modified', function(e) {
        var button = document.getElementById('saveModel');
        if (button) button.disabled = !myDiagram.isModified;
        var idx = document.title.indexOf('*');
        if (myDiagram.isModified) {
        if (idx < 0) document.title += '*';
        } else {
        if (idx >= 0) document.title = document.title.slice(0, idx);
        }
    });

    // var palette = new go.Palette('palette');

    myDiagram.linkTemplate = $(go.Link, {
        routing: go.Link.AvoidsNodes,
        curve: go.Link.JumpOver,
        corner: 3,
        relinkableFrom: true,
        relinkableTo: true,
        selectionAdorned: false, // Links are not adorned when selected so that their color remains visible.
        shadowOffset: new go.Point(0, 0),
        shadowBlur: 5,
        shadowColor: 'blue',
    }, new go.Binding('isShadowed', 'isSelected').ofObject(), $(go.Shape, { name: 'SHAPE', strokeWidth: 2, stroke: red }));

    var sharedToolTip =
        $(go.Adornment, "Auto",
        $(go.Shape, "RoundedRectangle", { fill: "lightyellow" }),
        $(go.TextBlock, { margin: 2 },
            new go.Binding("text",  "" , function(d) { return d.category; })));
    
    function nodeStyle() {
        return [
        new go.Binding('location', 'loc', go.Point.parse).makeTwoWay(go.Point.stringify),
        new go.Binding('isShadowed', 'isSelected').ofObject(),
        {
            selectionAdorned: false,
            shadowOffset: new go.Point(0, 0),
            shadowBlur: 15,
            shadowColor: 'blue',
            toolTip: sharedToolTip,
        },
        ];
    }

    function shapeStyle() {
        return {
            name: 'NODESHAPE',
            fill: 'lightgray',
            stroke: 'darkslategray',
            desiredSize: new go.Size(40, 40),
            strokeWidth: 2,
        };
    }

    function portStyle(input) {
        return {
            desiredSize: new go.Size(6, 6),
            fill: 'black',
            fromSpot: go.Spot.Right,
            fromLinkable: !input,
            toSpot: go.Spot.Left,
            toLinkable: input,
            toMaxLinks: 1,
            cursor: 'pointer',
        };
    }

    var inputTemplate = $(go.Node, 'Spot', nodeStyle(), $(go.Shape, 'Circle', shapeStyle(), { fill: red }), $(go.Shape, 'Rectangle', portStyle(false), { portId: '', alignment: new go.Spot(1, 0.5) }), {
        doubleClick: (e, obj) => {
            e.diagram.startTransaction('Toggle Input');
            var shp = obj.findObject('NODESHAPE');
            shp.fill = shp.fill === green ? red : green;
            updateStates();
            e.diagram.commitTransaction('Toggle Input');
        },
    });

    var outputTemplate = $(go.Node, 'Spot', nodeStyle(), $(go.Shape, 'Rectangle', shapeStyle(), { fill: green }), $(go.Shape, 'Rectangle', portStyle(true), { portId: '', alignment: new go.Spot(0, 0.5) }));

    var andTemplate = $(go.Node,
        'Spot',
        nodeStyle(),
        $(go.Shape, 'AndGate', shapeStyle()),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in1', alignment: new go.Spot(0, 0.3) }),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in2', alignment: new go.Spot(0, 0.7) }),
        $(go.Shape, 'Rectangle', portStyle(false), { portId: 'out', alignment: new go.Spot(1, 0.5) })
    );

    var orTemplate = $(go.Node,
        'Spot',
        nodeStyle(),
        $(go.Shape, 'OrGate', shapeStyle()),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in1', alignment: new go.Spot(0.16, 0.3) }),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in2', alignment: new go.Spot(0.16, 0.7) }),
        $(go.Shape, 'Rectangle', portStyle(false), { portId: 'out', alignment: new go.Spot(1, 0.5) })
    );

    var xorTemplate = $(go.Node,
        'Spot',
        nodeStyle(),
        $(go.Shape, 'XorGate', shapeStyle()),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in1', alignment: new go.Spot(0.26, 0.3) }),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in2', alignment: new go.Spot(0.26, 0.7) }),
        $(go.Shape, 'Rectangle', portStyle(false), { portId: 'out', alignment: new go.Spot(1, 0.5) })
    );

    var norTemplate = $(go.Node,
        'Spot',
        nodeStyle(),
        $(go.Shape, 'NorGate', shapeStyle()),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in1', alignment: new go.Spot(0.16, 0.3) }),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in2', alignment: new go.Spot(0.16, 0.7) }),
        $(go.Shape, 'Rectangle', portStyle(false), { portId: 'out', alignment: new go.Spot(1, 0.5) })
    );

    var nandTemplate = $(go.Node,
        'Spot',
        nodeStyle(),
        $(go.Shape, 'NandGate', shapeStyle()),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in1', alignment: new go.Spot(0, 0.3) }),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in2', alignment: new go.Spot(0, 0.7) }),
        $(go.Shape, 'Rectangle', portStyle(false), { portId: 'out', alignment: new go.Spot(1, 0.5) })
    );

    var notTemplate = $(go.Node,
        'Spot',
        nodeStyle(),
        $(go.Shape, 'Inverter', shapeStyle()),
        $(go.Shape, 'Rectangle', portStyle(true), { portId: 'in', alignment: new go.Spot(0, 0.5) }),
        $(go.Shape, 'Rectangle', portStyle(false), { portId: 'out', alignment: new go.Spot(1, 0.5) })
    );

    myDiagram.nodeTemplateMap.add('input', inputTemplate);
    myDiagram.nodeTemplateMap.add('output', outputTemplate);
    myDiagram.nodeTemplateMap.add('and', andTemplate);
    myDiagram.nodeTemplateMap.add('or', orTemplate);
    myDiagram.nodeTemplateMap.add('xor', xorTemplate);
    myDiagram.nodeTemplateMap.add('not', notTemplate);
    myDiagram.nodeTemplateMap.add('nand', nandTemplate);
    myDiagram.nodeTemplateMap.add('nor', norTemplate);

    load();
}

function updateStates() {
    var oldskip = myDiagram.skipsUndoManager;
    myDiagram.skipsUndoManager = true;
    myDiagram.nodes.each((node) => {
    if (node.category === 'input') {
        doInput(node);
    }
});
    myDiagram.nodes.each((node) => {
        switch (node.category) {
        case 'and':
            doAnd(node);
            break;
        case 'or':
            doOr(node);
            break;
        case 'xor':
            doXor(node);
            break;
        case 'not':
            doNot(node);
            break;
        case 'nand':
            doNand(node);
            break;
        case 'nor':
            doNor(node);
            break;
        case 'xnor':
            doXnor(node);
            break;
        case 'output':
            doOutput(node);
            break;
        case 'input':
            break;
    }
    });
    myDiagram.skipsUndoManager = oldskip;
}

function linkIsTrue(link) {
    return link.findObject('SHAPE').stroke === green;
}

function setOutputLinks(node, color) {
    node.findLinksOutOf().each((link) => (link.findObject('SHAPE').stroke = color));
}

function doInput(node) {
    setOutputLinks(node, node.findObject('NODESHAPE').fill);
}
function doAnd(node) {
    var color = node.findLinksInto().all(linkIsTrue) ? green : red;
    setOutputLinks(node, color);
}
function doNand(node) {
    var color = !node.findLinksInto().all(linkIsTrue) ? green : red;
    setOutputLinks(node, color);
}
function doNot(node) {
    var color = !node.findLinksInto().all(linkIsTrue) ? green : red;
    setOutputLinks(node, color);
}
function doOr(node) {
    var color = node.findLinksInto().any(linkIsTrue) ? green : red;
    setOutputLinks(node, color);
}
function doNor(node) {
    var color = !node.findLinksInto().any(linkIsTrue) ? green : red;
    setOutputLinks(node, color);
}
function doXor(node) {
    var truecount = 0;
    node.findLinksInto().each((link) => {
      if (linkIsTrue(link)) truecount++;
    });
    var color = truecount % 2 !== 0 ? green : red;
    setOutputLinks(node, color);
  }
function doOutput(node) {
    node.linksConnected.each((link) => {
        node.findObject('NODESHAPE').fill = link.findObject('SHAPE').stroke;
    });
}

function load() {
    myDiagram.model = go.Model.fromJson(json);
}

window.addEventListener('DOMContentLoaded', init);