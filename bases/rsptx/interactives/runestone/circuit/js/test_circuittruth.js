// *****************************************************************
// circuittruth.js. This file was created by Yana Yuan in April 2025.
// *****************************************************************
/*
 * - This file contains the JS for the logic circuit component.
 * - The goal for this component is to randomly generate a logic circuit in
 *   a visualized form and let the user fill in the truth table.
 * - Basic logic of this JS:
 *     - loadExternalScripts() imports from GoJS library. This usually is
 *       handled by HTML but since we don't have HTML file, loadScript() is
 *       used.
 *     - Generate text expression of the circuit such as (A NOR B) AND C:
 *     - generateCircuit() sets the parameters for the gates that should be 
 *       generated and calls the circuit generator class to create a boolean
 *       algebra statement. This is then handled by the class to create an
 *       AST that stores information about the circuit.
 *     - generateJSON() takes both the tree node and the text expression as 
 *       parameters and generate a JSON object ready to be loaded into the
 *       circuit visualization tool that GoJS library created.
 *       Here is the GoJS library sample:
 *          https://gojs.net/latest/samples/logicCircuit.html
 *       This function defines how the gates, inputs, and output are connected
 *       in JSON format and is one of the most important functions of this
 *       program. See more detailed explanations in the code below.
 *     - init() is the GoJS function that defines layout and behavior of 
 *       all logic gates we might need. Not really necessary to make any
 *       changes as the functionality is already desirable enough.
 *     - load() is where the JSON object generated by the generateJSON() is
 *       passed in.
 * 
*/
"use strict";

import { updateHeight } from "../../../utils/updateHeight.js";
import RunestoneBase from "../../common/js/runestonebase.js";
import "../css/circuittruth.css";
import circuit_generator from "./circuit_generate.js";

export var CircuitTruthList = {};

export default class CircuitTruth extends RunestoneBase {
    constructor(opts) {
        super(opts);
        var orig = opts.orig;
        this.origElem = orig;
        this.divid = orig.id;
        this.useRunestoneServices = opts.useRunestoneServices;
        document.body.classList.add('no-scroll');

        this.initCircuitElement();
        
        if (typeof Prism !== "undefined") {
            Prism.highlightAllUnder(this.containerDiv);
        }

        updateHeight(window, document, this, true, 1076);

    }

    initCircuitElement() {
        this.containerDiv = document.createElement("div");
        this.containerDiv.id = this.divid;

        this.instructionNode = document.createElement("div");
        // instruction text
        this.instructionNode.innerHTML = "<span style='font-weight:bold'><u>Instructions</u></span>: Given the randomly-generated circuit shown below, fill in the corresponding truth table.";
        this.instructionNode.style.padding = "10px";

        this.containerDiv.appendChild(this.instructionNode);

        
        this.statementDiv = document.createElement("div");

        this.statementDiv.className = "statement-div";

        this.configText = document.createElement("div");
        this.configText.style.display = "flex";
        this.configText.innerHTML = `<div style="margin-right: 2px;"> <span style='font-weight:bold'><u>Configure Question</u></span>: Select a mode to determine the circuit to generate: `
        this.modeText = document.createElement("div");
        this.modeText.innerHTML = "<ul><li>Mode 1 generates a smaller circuit containing only AND, OR, and NOT gates.</li><li>Mode 2 generates a larger circuit that can also contain NAND, NOR, and XOR gates.</li></ul>"
        
        
        this.modeSelect = document.createElement("select")
        this.modeSelect.style.width = "auto";
        this.modeSelect.className = "form-control fork-inline mode"
        this.mode1Option = document.createElement("option")
        this.mode1Option.value = "1"
        this.mode1Option.textContent = "1"
        this.modeSelect.append(this.mode1Option)

        this.mode2Option = document.createElement("option")
        this.mode2Option.value = "2"
        this.modeSelect.append(this.mode2Option)
        this.mode2Option.textContent = "2"

        this.modeSelect.setAttribute("id", `${this.divid}_modeSelect`)
        this.configText.append(this.modeSelect)
        this.statementDiv.append(this.configText);
        this.statementDiv.append(this.modeText)

        this.containerDiv.append(this.statementDiv);

        this.containerDiv.innerHTML += `
          <div class="container">
          <div id="${this.divid}_result"></div>
          <div id="${this.divid}_myDiagramDiv" style="width:600px; height:400px; border:1px solid gray; margin-bottom: 10px;"></div>
          <table id="${this.divid}_truthTable" border="1" cellspacing="0" cellpadding="5"></table>
          <br>
          <div class="button-row">
            <button id="${this.divid}_generateButton" class="btn btn-success">Generate another question</button>
            <button id="${this.divid}_showExpression" class="btn btn-success">Show expression</button>
            <button id="${this.divid}_checkButton" class="btn btn-success">Check answers</button>
          </div>
          <div id="${this.divid}_circuitOutput"></div>
          </div>
        `;

        $(this.origElem).replaceWith(this.containerDiv);

        this.loadExternalScripts();
    }

    loadExternalScripts() {
        const self = this;

        function loadScript(src, callback) {
            const s = document.createElement("script");
            s.src = src;
            s.onload = callback;
            s.onerror = () => console.error("Error loading script:", src);
            document.head.appendChild(s);
        }

        loadScript("https://cdn.jsdelivr.net/npm/gojs/release/go-debug.js", function() {
            loadScript("https://gojs.net/latest/extensions/PortShiftingTool.js", function() {
                go.Diagram.licenseKey =
"2b8647e1b2604fc702d90676423d6bbc5cf07d34cd960ef6590015f5ec5b6f40729be17906dad8c4d3f04df9487ac6d9ddc26c2ac31b003fe165d2df10f096ffb26424b2165b47daa40321c390f22ca0a97078f7cbb374a3dd7ed9f0effbc5985abcf2d740c95cb3792d0635066cbf4ce2abdf7bab52cd5d7b6e99a4fef6a856fa";
                import('./figures.js').then(()=>self.main());
            });
        });

    }

    main= ()=>{
        /* Global Variables */
        var json; // JSON to visualize the circuit
        const red = '#115222ff';
        const red2 = '#1a642eff';
        const green = '#0deb48ff';
        const green2 = '#33ff66ff';
        var myDiagram;
        let prevCircuit=null;

        const container   = this.containerDiv;
        const id          = this.divid;
        const diagramDiv  = `${id}_myDiagramDiv`;
        let mode = this.modeSelect.value;

        // Event listener for the Generate Circuit button
        container.querySelector(`#${id}_generateButton`).addEventListener('click', generateCircuit);
        container.querySelector(`#${id}_showExpression`).addEventListener('click', showExpression);
        container.querySelector(`#${id}_checkButton`).addEventListener('click', checkAnswers);
        container.querySelector(`#${id}_modeSelect`).addEventListener('change', changeMode);
        container.querySelector(`#${id}_modeSelect`).addEventListener('change', generateCircuit);
        
        document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();   // avoid accidental form submits or re-generates
            checkAnswers();
        }
        });


        function changeMode(){
            mode = (mode=="1") ? mode = "2": mode = "1";
        }

        let circuit_gen;
        function generateCircuit() {
            let inputs; // possible inputs
            let gates;  // the gates that are possible to generate
            let maxGates; // the maximum number of gates that can be generated
            let minGates; // the minimum number of gates that can be generated
            // note that maxGates and minGates needs to have a difference of at minimum of 1. If they are both set equal to N,
            // the range of possible number of gates is between N+1 and N.
            if(mode == "1"){
                gates = ['AND', 'OR', 'NOT'];
                inputs = ['A', 'B']
                maxGates = 3;
                minGates = 2;
            } else{
                gates = ['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'];
                inputs = ['A', 'B', 'C']
                maxGates = 5;
                minGates = 3;
            }
            // For more detailed documentation about the functionality and parameters of this class, see
            // circuit_generate.js
            circuit_gen = new circuit_generator(inputs, gates, maxGates, minGates, true, prevCircuit); 
            let circuit = circuit_gen.generateStatement();
            prevCircuit = circuit;

            // Ensures that A is used as one of the inputs for formatting purposes.
            const used = circuit_gen.getInformation().inputs;
            if (!used.includes('A')) {
                const toReplace = used.includes('B') ? 'B' : used[0];
                const re = new RegExp(`\\b${toReplace}\\b`);
                circuit = circuit.replace(re, 'A');
            }
            
            // update HTML to display the text. This is currently set invisible.
            container.querySelector(`#${id}_circuitOutput`).innerText = circuit

            // get the AST tree from the circuit_gen object.
            let ast = circuit_gen.getInformation().ast;
            // get the root of the AST from the circuit_gen object.
            let displayAST = circuit_gen.getInformation().root;
            
            // pass in the circuit expression to display truth table
            displayTruthTable(ast, circuit);


            // assign a JSON to the global variable json
            json = generateJSON(displayAST, ast);

            // default is to always set the circuit expression invisible
            const exprDiv = container.querySelector(`#${id}_circuitOutput`);
            exprDiv.style.visibility = 'hidden';

            // visualize the circuit
            if(myDiagram!=null){
                load();
                updateStates()
                myDiagram.redraw()
                updateStates()
                myDiagram.redraw()
                updateStates()
                myDiagram.redraw()
                updateStates()
                myDiagram.redraw()
                updateStates()
                myDiagram.redraw()
    
            }
            
        }

        /**
         * This function handles the truth table display.
         */
        function displayTruthTable(ast) {
            const inputs = circuit_gen.getInformation().inputs;
            const table = container.querySelector(`#${id}_truthTable`);
            table.innerHTML = ''; // Clear previous table

            // Create table header
            let header = '<tr>';
            for (const input of inputs) {
                header += `<th>${input}</th>`;
            }
            header += '<th>Output</th></tr>';
            table.innerHTML = header;

            // Retrieves truth table from the AST
            const numRows = Math.pow(2, inputs.length);
            let expected = ast.getTruthTable(inputs);
            for (let i = 0; i < numRows; i++) {
                const values = {};
                for (let j = 0; j < inputs.length; j++) {
                values[inputs[j]] = expected[i][j];
                }

                let row = '<tr>';
                for (const input of inputs) {
                row += `<td>${values[input] ? 1 : 0}</td>`;
                }
                // adjust the style by modifying content in .answer-input{} in circuittruth.css
                // here the input box only accepts one character as the input.

                row += `<td><input type="text" size="1" maxlength="1" class="answer-input" data-expected="${expected[i].pop()}" /></td>`;
                row += '</tr>';
                table.innerHTML += row;
            }

            // clear any previous result
            container.querySelector(`#${id}_result`).innerText = '';
        }
        
        /**
         * This function evaluates the user-inputted answers and give feedback.
         * The cell color changes to green when the answer is correct and red
         * if not.
         */
        function checkAnswers() {
            // Find every answer input
            let i = 0
            let inputNodes = document.getElementsByClassName('answer-input');
            container.querySelectorAll('.answer-input').forEach(input => {
                const expected = input.dataset.expected;
                const actual   = input.value.trim();
                // color the containing TD
                let td = input.parentElement;
                td.style.display = "flex"
                inputNodes[i].style = "margin-left:46.5%"
                let symbol;
                symbol = document.createElement("div")
                if (actual === expected) {
                  td.style.backgroundColor = '#f4fcfc';

                  let nodeToRemove = document.getElementById(`symbol${i}`);
                  if(nodeToRemove){
                    td.removeChild(nodeToRemove);
                  }
                  
                  
                  symbol.innerHTML = "✔️"
                  symbol.style = "margin-left:30%"
                  symbol.id = `symbol${i}`;
                  td.append(symbol);

                } else {
                  td.style.backgroundColor = '#f4dcdc';

                  let nodeToRemove = document.getElementById(`symbol${i}`);
                  if(nodeToRemove){
                    td.removeChild(nodeToRemove);
                  }
                  
                  symbol.innerHTML = "❌"
                  symbol.style = "margin-left:30%"
                  symbol.id = `symbol${i}`
                  td.append(symbol);
                }
                i++
            });
        }

        /**
         * Function to be executed when showExpression button is clicked.
         */
        function showExpression(){
            // grab the <div> that holds the expression
            const exprDiv = container.querySelector(`#${id}_circuitOutput`);
            // make it visible
            exprDiv.style.visibility = 'visible';
        }

        /**
         * Visualizes the tree structure in text. This is used during debugging so it is 
         * commented out in the generateCircuit function.
         * @param {*} node: parent node of the tree
         * @param {*} indent: indent of each item in the tree, for visualization
         * @returns 
         */
        function visualizeAST(node, indent = 0) {
            if (!node) return;
            let treeVisual = [];

            /** recursive helper function */
            function buildVisual(node, depth) {
                let spacing = ' '.repeat(depth * 2);
                if (node.type === 'INPUT') {
                    treeVisual.push(`${spacing}${node.value}`);
                } else {
                    treeVisual.push(`${spacing}${node.value}`);
                    node.children.forEach(child => buildVisual(child, depth + 1));
                }
            }
            buildVisual(node, indent);
            container.querySelector(`#${id}_astOutput`).innerText = treeVisual.join('\n');
        }

        /**
         * generateJSON
         * -------------
         * Transforms a parsed AST (`node`) and its original infix expression (`circuit`)
         * into the JSON model format required by GoJS.  This JSON contains:
         * 
         *   • nodeDataArray: an array of objects each describing a circuit element
         *     (inputs, gates, output) with a unique numeric key and an (x,y) location.
         * 
         *   • linkDataArray: an array of objects each describing a wire from one element
         *     to another, specifying the “fromPort” and “toPort” so GoJS knows exactly
         *     which gate port to hook up.
         * 
         * Design & Structure
         * ------------------
         * 1) **Input Extraction & Placement**  
         *    • Extract all input variables (A, B, C…) from the infix `circuit` string.  
         *    • Assign each input a unique negative ID and position them vertically
         *      along x=0 based on how many there are (evenly spaced).  
         * 
         * 2) **Layer Analysis**  
         *    • Walk the AST recursively to count how many gates exist at each depth.  
         *    • Store a “layers” map: depth → count, which helps determine x-coordinates.  
         * 
         * 3) **Gate Positioning**  
         *    • For each non-input node in the AST, use its depth to compute an x-position  
         *      (even slices of a fixed canvas width).  
         *    • Distribute multiple gates at the same depth vertically around y=0  
         *      (so they don’t all overlap). 
         * 
         * 4) **Output Node**  
         *    • After placing gates, append a single “output” node at the far right (x = max).  
         * 
         * 5) **Link Construction**  
         *    • Recursively traverse the AST again.  For each gate or input, emit link
         *      entries that connect child→parent using the correct port names (“in1”,
         *      “in2”, “in”, “out”).  
         *    • Leverage a helper (`getMinInput`) to decide input order port assignments
         *      so wires don’t cross arbitrarily.  
         * 
         * @param {{ type: string, value?: string, children?: any[] }} node
         *   The root node of the parsed AST for the circuit.
         * 
         * @param {string} circuit
         *   The original circuit expression, e.g. "(A AND B) OR NOT C".
         * 
         * @returns {{ class: string, nodeDataArray: object[], linkDataArray: object[] }}
         *   A JSON object ready for GoJS, containing `nodeDataArray` and `linkDataArray`.
         */
        function generateJSON(node, circuit) {
            // Arrays to collect all node definitions and link definitions.
            let nodeDataArray = [];
            let linkDataArray = [];

            // We'll assign negative IDs to each generated node.
            let nodeId = -1;
            // Extract and sort all unique input labels (e.g., A, B, C).
            let inputNodes = circuit.getInformation().inputs; 
            inputNodes.sort();
            let inputKeyMapping = {};
            // Helper to get a new unique node ID.
            function getNextNodeId() {
                return nodeId--;
            }

            /**
             * Create and position input nodes on the left side.
             * We map each label to a unique ID and Y-coordinate based on
             * input count, leaving X=0.
             */
            function generateInputNodes(inputNodes) {
                // Define vertical ordering for inputs. A on top.
                let stagger = -130;
                const inputOrder = { 'A': 5, 'B': 4, 'C': 3, 'D' : 2, 'E':1, 'F' : 0};
                inputNodes.sort((a, b) => inputOrder[a] - inputOrder[b]);
                inputNodes.forEach((input, index) => {
                    let inputId = getNextNodeId();
                    inputKeyMapping[input] = inputId;
                    let locationY;
                    // Determine Y position based on number of inputs.
                    // There are three cases.
                    //   - if 1 input, it is just in the middle
                    //   - if 2 inputs, they each is a certain distance from y-axis.
                    //   - if 3 inputs, B is in the middle. AC above and below.
                    if (inputNodes.length === 1) {
                        locationY = 0;
                    } else if (inputNodes.length === 2) {
                        locationY = (index === 0) ? 110 : -110; //I currently set the separation to be 110
                    } else if (inputNodes.length === 3) {
                        if (index === 0) {
                        locationY = 160;
                        } else if (index === 1) {
                        locationY = 20;
                        } else {
                        locationY = -120;
                        }
                    }
                    // Add the input node to the array with its position and label.
                    nodeDataArray.push({
                        category: 'input',
                        key: inputId,
                        loc: `${stagger} ${locationY} `,
                        label: input,
                        isOn: false
                    });
                    stagger+=10;
                });
            }
            generateInputNodes(inputNodes);

            /**
             * Walks the AST to count how many gates (non-input nodes) appear
             * at each tree depth.  Returns an object { depth: count, ... }.
             */
            function preprocessTree(node, depth = 0, layers = {}) {
                if (node.type === 'INPUT') return; // skip input leaves
                layers[depth] = (layers[depth] || 0) + 1; // increment gate count at this depth
                node.children.forEach(child => preprocessTree(child, depth + 1, layers));
                return layers;
            }
            let layers = preprocessTree(node);
            
            // Next ID for placing gates (start after inputs).
            let currId = -inputNodes.length - 1;

            /**
             * Recursively position each gate node in a grid:
             *  - X coordinate determined by depth and total number of layers
             *  - Y coordinate distributed evenly around center based on how many
             *    gates are in that depth.
             */
            let set2 = [];
            let set3 = [];
            function setPosition(node, depth = 0, layers, positions = {}, stagger=20) {
                if (node.type === 'INPUT') return;
                let inputCount = circuit_gen.getInformation().numInputs;
                let width = 400; // Set the width of the canvas to be 400.
                let numLevels = Object.keys(layers).length; // Number of layers = number of unique depths
                let interval = width / (numLevels + 1); // Horizontal spacing between layers
                let xPosition = width - interval * (depth + 1)+stagger;
                let yPosition = -10;

                // Determine vertical slot for this node within its depth
                if (!positions[depth]) positions[depth] = 0;
                positions[depth]++;
                if(node.value == "NOT"){
                    switch(inputCount){
                        case 2:
                            if(node.children[0].value == "A"){
                                yPosition = -113.5
                            }else if(node.children[0].value == "B"){
                                yPosition = 106.5
                            }
                            break;
                        case 3:
                            if(node.children[0].value == "A"){
                                yPosition = -123.5
                            }else if (node.children[0].value == "C"){
                                yPosition = 156.5
                            }
                            break;
                    }
                }else{
                    switch(inputCount){
                        case 2:
                            if((node.children[0].value == "A" && node.children[1].value == "B") || (node.children[0].value == "B" && node.children[1].value == "A")){
                                if(set2.length == 0){
                                    yPosition = -70;
                                    set2.push(-70)
                                }else{
                                    yPosition = 50;
                                }
                                
                            }
                            break;
                        case 3:
                            if((node.children[0].value == "A" && node.children[1].value == "B") || (node.children[0].value == "B" && node.children[1].value == "A")){
                                if(!set3.includes(-60)){
                                    yPosition = -75
                                    xPosition+=15
                                    set3.push(-60)
                                }else{
                                    yPosition = 75
                                    xPosition+=15
                                    set3.push(60)
                                }

                            }else if ((node.children[0].value == "C" && node.children[1].value == "B") || (node.children[0].value == "B" && node.children[1].value == "C")){
                                if(!set3.includes(60)){
                                    yPosition = 75
                                    set3.push(60)
                                }else{
                                    yPosition = -75
                                    set3.push(-60)
                                }
                            }
                            break;
                    }
                }
                
                // Add gate node with its calculated position.
                nodeDataArray.push({
                    category: node.value.toLowerCase(),
                    key: currId--,
                    loc: `${xPosition} ${yPosition}`
                });
                // Recurse into children gates.
                node.children.forEach((child) => {
                    setPosition(child, depth + 1, layers, positions, stagger)
                    stagger-=40
                });
                set3=[];
                
            }
            setPosition(node, 0, layers);

            // After placing gates, add the single output node on the right edge.
            let outputId = currId;
            nodeDataArray.push({
                category: "output",
                key: outputId,
                loc: "400 -40"
            });
            // Connect the last gate to the output as recursion doesn't cover it.
            linkDataArray.push({
                from: -inputNodes.length - 1,
                to: outputId,
                fromPort: 'out',
                toPort: ''
            });

            // Utility to decide port assignment order to minimize wire crossings.
            const inputOrderMapping = { 'A': 0, 'B': 1, 'C': 2, 'D' : 3, 'E' : 4, 'F' : 5, 'G' : 6};
            /**
             * Finds the lexicographically minimal input label under a subtree,
             * used to decide which child goes to in1 vs in2.
             */
            function getMinInput(node) {
                if (node.type === 'INPUT') return node.value;
                let minLetter = null;
                if (node.children && node.children.length) {
                    node.children.forEach(child => {
                        let candidate = getMinInput(child);
                        if (candidate && (minLetter === null || inputOrderMapping[candidate] < inputOrderMapping[minLetter])) {
                            minLetter = candidate;
                        }
                    });
                }
                return minLetter;
            }

            /** Recursively traverse the AST to emit all link definitions. */
            function traverse(node, parentId = null, parentPort = null, depth = 0) {
                let currentId;
                // For inputs, link directly to parent gate/output.
                if (node.type === 'INPUT') {
                    if (parentId !== null) {
                        linkDataArray.push({
                            from: inputKeyMapping[node.value],
                            to: parentId,
                            fromPort: '',
                            toPort: parentPort
                        });
                    }
                    return;
                } else {
                    // Non-input: assign new ID for this gate’s output
                    currentId = getNextNodeId();
                }
                if (node.children) {
                    if (node.children.length === 2) { // binary gate
                        // Choose ports to minimize crossing
                        let min0 = getMinInput(node.children[0]) || '';
                        let min1 = getMinInput(node.children[1]) || '';
                        let portAssignments;
                        if (!min0 || !min1 || min0 === min1) {
                            portAssignments = ['in1', 'in2'];
                        } else if (inputOrderMapping[min0] <= inputOrderMapping[min1]) {
                            portAssignments = ['in1', 'in2'];
                        } else {
                            portAssignments = ['in2', 'in1'];
                        }

                        let usedPorts = new Set();
                        // For each child, assign it to in1 or in2
                        node.children.forEach((child, i) => {
                        let port = portAssignments[i];
                        // Force A→in1, C→in2 if child is a direct input
                        if (child.type === 'INPUT') {
                            if (child.value === 'A') port = 'in1';
                            else if (child.value === 'C') port = 'in2';
                        }
                        // Avoid duplicate port usage
                        if (usedPorts.has(port)) {
                            port = (port === 'in1') ? 'in2' : 'in1';
                        }
                        usedPorts.add(port);
                        if (child.type === 'INPUT') {
                            // Direct link from input to this gate
                            linkDataArray.push({
                                from: inputKeyMapping[child.value],
                                to: currentId,
                                fromPort: '',
                                toPort: port
                            });
                        } else {
                            // Recurse for nested gates
                            traverse(child, currentId, port, depth + 1);
                        }
                        });
                    } else { // single child, very similar to the above logic
                        let children = node.children.slice();
                        children.sort((a, b) => {
                            let minA = getMinInput(a) || '';
                            let minB = getMinInput(b) || '';
                            return inputOrderMapping[minA] - inputOrderMapping[minB];
                        });
                        children.forEach((child, index) => {
                        let port = (index === 0) ? 'in' : 'in';
                        if (child.type === 'INPUT') {
                            if (child.value === 'A') port = 'in';
                            else if (child.value === 'C') port = 'in';
                        }
                        if (child.type === 'INPUT') {
                            linkDataArray.push({
                            from: inputKeyMapping[child.value],
                            to: currentId,
                            fromPort: '',
                            toPort: port
                            });
                        } else {
                            traverse(child, currentId, port, depth + 1);
                        }
                        });
                    }
                }
                // Finally, link this gate’s output to its parent node/port
                if (parentId !== null) {
                linkDataArray.push({
                    from: currentId,
                    to: parentId,
                    fromPort: 'out',
                    toPort: parentPort
                });
                }
            }
            // Kick off the link generation from the AST root
            traverse(node);

            // Return the GoJS model JSON
            return {
                class: "go.GraphLinksModel",
                linkFromPortIdProperty: "fromPort",
                linkToPortIdProperty: "toPort",
                nodeDataArray: nodeDataArray,
                linkDataArray: linkDataArray
            };
        }

        /*==============================================
        === Circuit Visualization using GoJS Library ===
        ===============================================*/
        /**
         * All functions below are rarely modified other than deletion of features we
         * don't want for this component, such as dragging gates from the palette to
         * the canvas. So I won't exhaustively comment the codes below because I
         * didn't write these. They are directly from GoJS Library.
         * What those functions mainly do is defining the style of the gates. If you 
         * want to modify anything, just stick to JSON and CSS format then it should
         * work.
         * load() function below is where JSON object is passed in.
         */
        function init() {
              
            const red = '#115222ff';
            const red2 = '#1a642eff';
            const green = '#0deb48ff';
            const green2 = '#33ff66ff';

            const gray = '#cbd5e1';
            const darkGray = '#334155';
            myDiagram = new go.Diagram(diagramDiv, {
                'draggingTool.isGridSnapEnabled': true, // dragged nodes will snap to a grid of 10x10 cells
                'undoManager.isEnabled': true,
                'grid.visible': false
              });
          
            myDiagram.toolManager.draggingTool.isGridSnapEnabled = false

              // when the document is modified, add a "*" to the title and enable the "Save" button
              myDiagram.addDiagramListener('Modified', (e) => {
                const button = document.getElementById('saveModel');
                if (button) button.disabled = !myDiagram.isModified;
                const idx = document.title.indexOf('*');
                if (myDiagram.isModified) {
                  if (idx < 0) document.title += '*';
                } else {
                  if (idx >= 0) document.title = document.title.slice(0, idx);
                }
              });
          
          
              // creates relinkable Links that will avoid crossing Nodes when possible and will jump over other Links in their paths
              myDiagram.linkTemplate = new go.Link({
                routing: go.Routing.AvoidsNodes,
                curve: go.Curve.JumpOver,
                corner: 3,
                relinkableFrom: true,
                relinkableTo: true,
                selectionAdorned: false, // Links are not adorned when selected so that their color remains visible.
                shadowOffset: new go.Point(0, 0),
                shadowBlur: 5,
                shadowColor: 'blue',
                layerName: 'Background'
              })
                .bindObject('isShadowed', 'isSelected')
                .add(new go.Shape({ name: 'SHAPE', strokeWidth: 3, stroke: red }));
          
              // node template helpers
              const sharedToolTip = go.GraphObject.build('ToolTip', {
                'Border.figure': 'RoundedRectangle'
              }).add(new go.TextBlock({ margin: 2 }).bind('text', '', (d) => d.category));
          
              // define some common property settings
              function nodeStyle() {
                return {
                  selectionAdorned: false,
                  shadowOffset: new go.Point(0, 0),
                  shadowBlur: 15,
                  shadowColor: 'blue',
                  toolTip: sharedToolTip
                };
              }
          
              function applyNodeBindings(node) {
                node.bindTwoWay('location', 'loc', go.Point.parse, go.Point.stringify);
                node.bindObject('isShadowed', 'isSelected');
                return node;
              }
          
              function shapeStyle() {
                return {
                  name: 'NODESHAPE',
                  fill: gray,
                  stroke: darkGray,
                  desiredSize: new go.Size(40, 40),
                  strokeWidth: 2
                };
              }
          
              function portStyle(input, spot) {
                return {
                  figure: 'Rectangle',
                  desiredSize: new go.Size(4, 4),
                  fill: darkGray,
                  stroke: 'transparent',
                  strokeWidth: 6,
                  fromLinkable: !input,
                  fromSpot: spot ?? new go.Spot(1, 0.5, -3, 0),
                  toSpot: spot ?? new go.Spot(0, 0.5, 3, 0),
                  toLinkable: input,
                  toMaxLinks: 1,
                  cursor: 'pointer'
                };
              }
          

            const nodeOnClickFunction = (e, obj) => {
                if (e.diagram instanceof go.Palette) return;
                e.diagram.startTransaction('Toggle Input');

                const isOn = !obj.data.isOn;
                myDiagram.model.setDataProperty(obj.data, 'isOn', isOn);
                
                updateStates();
                e.diagram.commitTransaction('Toggle Input');
            }

              // define templates for each type of node
          
              const BottomLabelAlignment = new go.Spot(0.5, 1, 0, 10);


              //The text bindings are how I get the number/category type on the input. What's weird is that margin doesn't seem to work
              //changing this will be a pain.
              const inputTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
                  .set({
                      cursor: 'pointer',
                      margin: new go.Margin(-15, 0, 0, 0),
                      click: (e, obj) => {
                          nodeOnClickFunction(e, obj)
                      },
                      deletable : false,
                      movable : true,
                  })
              .add(
              new go.Shape('inputTemplate', {
                      name: 'NODESHAPE',
                      fill: gray,
                      stroke: darkGray,
                      strokeWidth: 2
                  })
                      .set({
                          fill: go.Brush.lighten(green),
                          margin: 3,
                          strokeWidth: 1.5,
                          desiredSize: new go.Size(40, 40),
                          scale: 1,
                      })
                  .bind('fill', 'isOn', isOn => go.Brush.lighten(isOn ? green : red)),
              new go.Shape(portStyle(false)) // the only port
                      .set({
                      opacity: 1,
                      portId: '',
                      alignment: new go.Spot(1, 0.5, -2.5, 0),
                  })
                  .bind("fill", "isOn", isOn => isOn ? "black": "white"),
              new go.TextBlock({margin: 4, alignment: new go.Spot(0.5, 1, 0, 10)}).bind("text", "label", label => `Input ${label}`),
              new go.TextBlock({margin: 4, alignment: new go.Spot(0.5, 0.5, -5, 3), font: '20px mono', stroke: 'white'}).bind("text", "isOn", isOn => isOn ? "1" : "0").bind("stroke", "isOn", isOn => isOn ? "black": "white"),

              );



              const outputTemplate = new go.Node('Spot', nodeStyle())
              .set({
              isShadowed: true,
              deletable : false,
              movable : true,
              })
              .bindTwoWay('location', 'loc', go.Point.parse, go.Point.stringify)
              .add(
              new go.Panel('Spot')
                  .add(
                  new go.Shape('OutputTemplate', {
                      fill: 'transparent',
                      parameter1: Infinity,
                      parameter2: 0b0011, // top rounded
                      width: 44,
                      height: 38,
                      strokeWidth: 2,
                      shadowVisible: false
                  })
                  .set({ fill: go.Brush.lighten(green)})
                  .bind('fill', 'isOn', isOn => go.Brush.lighten(isOn ? green : red)),


                  ),
              new go.Shape(portStyle(true, new go.Spot(0, 0.5, 0, 0))).set({
                  // the only port
                  portId: '',
                  alignment: new go.Spot(0, 0.5, 5, 0),
              })
              .bind("fill", "isOn", isOn => isOn ? "black": "white"),
              new go.TextBlock({margin: 4, alignment: new go.Spot(0.5, 1, 0, 10)}).bind("text", "text", text => `Output ${text}`),
              new go.TextBlock({margin: 4, alignment: new go.Spot(0.5, 0.5, -3, 3),  font: '15px mono', stroke: 'white'}).bind("text", "isOn", isOn => isOn ? "1" : "0").bind("stroke", "isOn", isOn => isOn ? "black": "white"),
              );

              const andTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
              .add(
              new go.Shape('AndGate', shapeStyle()),
              new go.Shape(portStyle(true)).set({
                  portId: 'in1',
                  alignment: new go.Spot(0, 0.3)
              }),
              new go.Shape(portStyle(true)).set({
                  portId: 'in2',
                  alignment: new go.Spot(0, 0.7)
              }),
              new go.Shape(portStyle(false)).set({
                  portId: 'out',
                  alignment: new go.Spot(1, 0.5)
              })
              )
              .add(new go.TextBlock({ margin: new go.Margin(10,2,2,2), alignment: BottomLabelAlignment }).bind('text', '', (d) => d.category))
              ;

              const orTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
              .add(
              new go.Shape('OrGate', shapeStyle()),
              new go.Shape(portStyle(true)).set({
                  portId: 'in1',
                  alignment: new go.Spot(0.16, 0.3)
              }),
              new go.Shape(portStyle(true)).set({
                  portId: 'in2',
                  alignment: new go.Spot(0.16, 0.7)
              }),
              new go.Shape(portStyle(false)).set({
                  portId: 'out',
                  alignment: new go.Spot(1, 0.5)
              })

              )
              .add(new go.TextBlock({ margin: 2, alignment: BottomLabelAlignment }).bind('text', '', (d) => d.category))
              ;

              const xorTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
              .add(
              new go.Shape('XorGate', shapeStyle()),
              new go.Shape(portStyle(true)).set({
                  portId: 'in1',
                  alignment: new go.Spot(0.26, 0.3)
              }),
              new go.Shape(portStyle(true)).set({
                  portId: 'in2',
                  alignment: new go.Spot(0.26, 0.7)
              }),
              new go.Shape(portStyle(false)).set({
                  portId: 'out',
                  alignment: new go.Spot(1, 0.5)
              })
              )
              .add(new go.TextBlock({ margin: new go.Margin(2,2,2,2), alignment: BottomLabelAlignment }).bind('text', '', (d) => d.category))
              ;

              const norTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
              .add(
              new go.Shape('NorGate', shapeStyle()),
              new go.Shape(portStyle(true)).set({
                  portId: 'in1',
                  alignment: new go.Spot(0.16, 0.3)
              }),
              new go.Shape(portStyle(true)).set({
                  portId: 'in2',
                  alignment: new go.Spot(0.16, 0.7)
              }),
              new go.Shape(portStyle(false)).set({
                  portId: 'out',
                  opacity: 0,
                  alignment: new go.Spot(1, 0.5, -5, 0)
              })
              )
              .add(new go.TextBlock({ margin: new go.Margin(2,2,2,2), alignment: BottomLabelAlignment }).bind('text', '', (d) => d.category))
              ;


              const nandTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
              .add(
              new go.Shape('NandGate', shapeStyle()),
              new go.Shape(portStyle(true)).set({
                  portId: 'in1',
                  alignment: new go.Spot(0, 0.3)
              }),
              new go.Shape(portStyle(true)).set({
                  portId: 'in2',
                  alignment: new go.Spot(0, 0.7)
              }),
              new go.Shape(portStyle(false)).set({
                  portId: 'out',
                  opacity: 0,
                  alignment: new go.Spot(1, 0.5, -5, 0)
              })
              )
              .add(new go.TextBlock({ margin: new go.Margin(2,2,2,2), alignment: BottomLabelAlignment}).bind('text', '', (d) => d.category))
              ;

              const notTemplate = applyNodeBindings(new go.Node('Spot', nodeStyle()))
              .add(
              new go.Shape('Inverter', shapeStyle()),
              new go.Shape(portStyle(true)).set({
                  portId: 'in',
                  alignment: new go.Spot(0, 0.5)
              }),
              new go.Shape(portStyle(false)).set({
                  portId: 'out',
                  opacity: 0,
                  alignment: new go.Spot(1, 0.5, -5, 0)
              })
              )
              .add(new go.TextBlock({ margin: new go.Margin(2,2,2,2), alignment: BottomLabelAlignment }).bind('text', '', (d) => d.category))
              ;
          
              myDiagram.nodeTemplateMap.add('input', inputTemplate);
              myDiagram.nodeTemplateMap.add('output', outputTemplate);
              myDiagram.nodeTemplateMap.add('and', andTemplate);
              myDiagram.nodeTemplateMap.add('or', orTemplate);
              myDiagram.nodeTemplateMap.add('xor', xorTemplate);
              myDiagram.nodeTemplateMap.add('not', notTemplate);
              myDiagram.nodeTemplateMap.add('nand', nandTemplate);
              myDiagram.nodeTemplateMap.add('nor', norTemplate);
          
          
              // load the initial diagram
              load();
              updateStates()
              myDiagram.redraw()
              updateStates()
              myDiagram.redraw()
              updateStates()
              myDiagram.redraw()
              updateStates()
              myDiagram.redraw()
              updateStates()
              myDiagram.redraw()
          
              // continually update the diagram
              loop();
            }
          
            // update the diagram every 250 milliseconds
            function loop() {
              setTimeout(() => {
                updateStates();
                loop();
              }, 250);
            }
          
            // update the value and appearance of each node according to its type and input values
            function updateStates() {
              const oldskip = myDiagram.skipsUndoManager;
              myDiagram.skipsUndoManager = true;
              // do all "input" nodes first
              myDiagram.nodes.each((node) => {
                if (node.category === 'input') {
                  doInput(node);
                }
              });
              // now we can do all other kinds of nodes
              myDiagram.nodes.each((node) => {
                switch (node.category) {
                  case 'switch':
                    doSwitch(node);
                    break;
                  case 'and':
                    doAnd(node);
                    break;
                  case 'or':
                    doOr(node);
                    break;
                  case 'xor':
                    doXor(node);
                    break;
                  case 'not':
                    doNot(node);
                    break;
                  case 'nand':
                    doNand(node);
                    break;
                  case 'nor':
                    doNor(node);
                    break;
                  case 'xnor':
                    doXnor(node);
                    break;
                  case 'output':
                    doOutput(node);
                    break;
                  case 'input':
                    break; // doInput already called, above
                }
              });
              myDiagram.skipsUndoManager = oldskip;
            }
          
            // helper predicate
            function linkIsTrue(link) {
              // assume the given Link has a Shape named "SHAPE"
              return link.findObject('SHAPE').stroke === green;
            }
          
            // helper function for propagating results
            function setOutputLinks(node, color) {
              node.findLinksOutOf().each((link) => (link.findObject('SHAPE').stroke = color));
            }
          
            // update nodes by the specific function for its type
            // determine the color of links coming out of this node based on those coming in and node type
          
            function doInput(node) {
              setOutputLinks(node, node.data.isOn ? green : red);
            }
          
            function doSwitch(node) {
              const linksInto = node.findLinksInto();
              const color = linksInto.count > 0 && linksInto.all(linkIsTrue) ? green : red;
              node.findObject('NODESHAPE').fill = color;
              let ang = node.findObject('NODESHAPE').panel.angle;
              let isGoodAngle = ang >= 357 || ang <= 3;
              setOutputLinks(node, node.data.isOn && isGoodAngle ? color : red);
            }
          
            function doAnd(node) {
              const linksInto = node.findLinksInto();
              const color = linksInto.count > 0 && linksInto.all(linkIsTrue) && linksInto.count % 2 == 0 ? green : red;
              setOutputLinks(node, color);
            }
            function doNand(node) {
              const color = !node.findLinksInto().all(linkIsTrue) ? green : red;
              setOutputLinks(node, color);
            }
            function doNot(node) {
              const color = !node.findLinksInto().all(linkIsTrue) ? green : red;
              setOutputLinks(node, color);
            }
          
            function doOr(node) {
              const color = node.findLinksInto().any(linkIsTrue) ? green : red;
              setOutputLinks(node, color);
            }
            function doNor(node) {
              const color = !node.findLinksInto().any(linkIsTrue) ? green : red;
              setOutputLinks(node, color);
            }
          
            function doXor(node) {
              let truecount = 0;
              node.findLinksInto().each((link) => {
                if (linkIsTrue(link)) truecount++;
              });
              const color = truecount % 2 !== 0 ? green : red;
              setOutputLinks(node, color);
            }
            function doXnor(node) {
              let truecount = 0;
              node.findLinksInto().each((link) => {
                if (linkIsTrue(link)) truecount++;
              });
              const color = truecount % 2 === 0 ? green : red;
              setOutputLinks(node, color);
            }
          
            function doOutput(node) {
              // assume there is just one input link
              // we just need to update the node's data.isOn
              node.linksConnected.each((link) => {
                myDiagram.model.setDataProperty(node.data, 'isOn', link.findObject('SHAPE').stroke == green);
              });
            }

            function load() {
              myDiagram.model = go.Model.fromJson(json);
        }
        // Start by initializing the diagram and generating a circuit.

        
        generateCircuit();
        init();
        
        
        
    }
    
    recordAnswered() {
        this.isAnswered = true;
    }
}
    /*=================================
    == Find the custom HTML tags and ==
    ==   execute our code on them    ==
    =================================*/
    $(document).on("runestone:login-complete", function () {
        $("[data-component=test_circuittruth]").each(function () {
            var opts = {
                orig: this,
                useRunestoneServices: eBookConfig.useRunestoneServices
            };
            if ($(this).closest("[data-component=timedAssessment]").length === 0) {
                try {
                    CircuitTruthList[this.id] = new CircuitTruth(opts);
                } catch (err) {
                    console.log(`Error rendering CircuitTruth ${this.id} — Details: ${err}`);
                }
            }
        });
    });
